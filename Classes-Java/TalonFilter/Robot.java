// DISPLAY TalonFX (Falcon 500) velocity native units versus time for selected %VBus, filterWindow size, and filterPeriod length

// Copy of CTRE method help
  /**
   * configVelocityMeasurementWindow
	 * Sets the number of velocity samples used in the rolling average velocity
	 * measurement.
	 *
	 * @param windowSize
	 *            Number of samples in the rolling average of velocity
	 *            measurement. Valid values are 1,2,4,8,16,32. If another
	 *            value is specified, it will truncate to nearest support value.
	 * @return Error Code generated by function. 0 indicates no error.
	 */

	/**
   * configVelocityMeasurementPeriod
	 * Configures the period of each velocity sample.
	 * Every 1ms a position value is sampled, and the delta between that sample
	 * and the position sampled kPeriod ms ago is inserted into a filter.
	 * kPeriod is configured with this function.
	 *
	 * @param period
	 *            Desired period for the velocity measurement. @see
	 *            com.ctre.phoenix.sensors.SensorVelocityMeasPeriod
	 * @return Error Code generated by function. 0 indicates no error.
	 */

package frc.robot;

import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;

import edu.wpi.first.hal.HAL;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.RobotBase;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonFX;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.sensors.SensorVelocityMeasPeriod;

  public class Robot extends RobotBase {
  
    public void disabled() {}
  
    public void autonomous() {}
  
    public void test() {}
  
    private volatile boolean m_exit;
  
  TalonFX flywheelMotor;
  private static final int TIMEOUT_MS = 30; //milliseconds
  final int pidIdx = 0; // Talon primary closed loop control (or none)

  BiConsumer<Double, Double> printSpeed;
  Consumer<Double> setFlywheelControlSignal;
  Supplier<Double> getFlywheelSpeed;
  
  double controlSignal = 0.; // %VBus
  int filterWindow = 1;
  double filterPeriod = 100.;
  
  private static final int sampleTime = 5; // milliseconds robot loop sample time period

  Timer time = new Timer();

  private double flip = -1.;

  Robot()
  {
    LiveWindow.disableAllTelemetry(); // don't waste time on stuff we don't need
  }

  /**
   * main loop
   */
  @Override
  public void startCompetition() {
    robotInit();

    // Done with initialization so tell the DS that the robot code is ready
    HAL.observeUserProgramStarting();

    // Loop forever, calling the appropriate functions
    while (true) {
      // loopFunc();

      // sweep velocities through periods
      sweepVelocity();

    }

  }

  @Override
  public void endCompetition() {
    m_exit = true;
  }

  public void robotInit() {

    configFlywheel();

    System.out.println("Select rolling average window size 1,2,4,8,16,32 ms.\nBigger is smoother and more lag.");

    System.out.println("Select accumulator look-back period ms from list. Incorrect values become 100ms.\nBigger gives more significant digits and more lag.");
    for(SensorVelocityMeasPeriod svmp : SensorVelocityMeasPeriod.values())
    {
      System.out.println(svmp);
    };

    printSpeed.accept(controlSignal, 0.);
  }

  private void loopFunc()
  {
    while (!Thread.currentThread().isInterrupted() && !m_exit) {
      if (isDisabled()) {
        DriverStation.inDisabled(true);
        disabled();
        DriverStation.inDisabled(false);
        /*while*/ if (isDisabled()) {
          DriverStation.waitForData();
        }
      } else if (isAutonomous()) {
        DriverStation.inAutonomous(true);
        autonomous();
        DriverStation.inAutonomous(false);
        /*while*/ if (isAutonomousEnabled()) {
          DriverStation.waitForData();
        }
      } else if (isTest()) {
        LiveWindow.setEnabled(true);
        Shuffleboard.enableActuatorWidgets();
        DriverStation.inTest(true);
        test();
        DriverStation.inTest(false);
        /*while*/ if (isTest() && isEnabled()) {
          DriverStation.waitForData();
        }
        LiveWindow.setEnabled(false);
        Shuffleboard.disableActuatorWidgets();
      } else {
        DriverStation.inTeleop(true);
        teleop();
        DriverStation.inTeleop(false);
        /*while*/ if (isTeleopEnabled()) {
          DriverStation.waitForData();
          // DriverStation.waitForData(0.1);// () (0) (seconds)
          // DriverStation.isNewControlData();
        }
      }
    }
  }
  public void teleop() {
  
    System.out.println("teleop entered");
    // try {
    //   Thread.sleep(10);
    // } catch (InterruptedException e) {
    //   // TODO Auto-generated catch block
    //   e.printStackTrace();
    // }

    // System.out.format("%5.2f %5d %5.2f %5.2f %5.2f\n", robbie.controlSignal, robbie.filterWindow, robbie.filterPeriod, vmin, vmax);

    controlSignal = SmartDashboard.getNumber("%VBus", controlSignal);

    filterWindow = (int)SmartDashboard.getNumber("filter window", filterWindow);

    flywheelMotor.configVelocityMeasurementWindow(filterWindow/*, TIMEOUT_MS*/);

    filterPeriod = SmartDashboard.getNumber("filter period", filterPeriod);

    flywheelMotor.configVelocityMeasurementPeriod(SensorVelocityMeasPeriod.valueOf(filterPeriod)/*, TIMEOUT_MS*/);

    setFlywheelControlSignal.accept(controlSignal);
    var speed = getFlywheelSpeed.get();
    printSpeed.accept(controlSignal, speed);

    System.out.println("teleop returned");

  }

  void configFlywheel()
  {
      int flywheelMotorPort=0;
      flywheelMotor = new TalonFX(flywheelMotorPort);
      System.out.println("[Talon] set factory default " + flywheelMotor.configFactoryDefault(TIMEOUT_MS));
      flywheelMotor.setInverted(false);
      flywheelMotor.setNeutralMode(NeutralMode.Coast);
      System.out.println("[Talon] set vel period " + flywheelMotor.configVelocityMeasurementPeriod(SensorVelocityMeasPeriod.Period_25Ms, TIMEOUT_MS));
      System.out.println("[Talon] set vel window " + flywheelMotor.configVelocityMeasurementWindow(1, TIMEOUT_MS));
      FeedbackDevice sensor = FeedbackDevice.IntegratedSensor;
      System.out.println("[Talon] set feedback sensor " + sensor.toString() + " " + flywheelMotor.configSelectedFeedbackSensor(sensor, 0, TIMEOUT_MS));
      System.out.println("[Talon] set nominal output reverse " + flywheelMotor.configNominalOutputReverse(0., TIMEOUT_MS));
      System.out.println("[Talon] set status 2 " + flywheelMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, sampleTime, TIMEOUT_MS));
      System.out.println("[Talon] set status 13 " + flywheelMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, sampleTime, TIMEOUT_MS)); // PID error
      flywheelMotor.setSensorPhase(false);
      flywheelMotor.setSelectedSensorPosition(0);

      setFlywheelControlSignal = (speed) -> 
      {
        flywheelMotor.set(TalonFXControlMode.PercentOutput, speed);
        if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set error " + flywheelMotor.getLastError());
      };

      getFlywheelSpeed = () ->
      {
        var speed = flywheelMotor.getSelectedSensorVelocity(pidIdx);
        if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("get sensor error " + flywheelMotor.getLastError());
        return speed;
      };

      // printSpeed = (controlSignal, speed) -> System.out.println("%VBus " + controlSignal + ", velocity (native units) " + speed);
      printSpeed = (controlSignal, speed) -> {
        SmartDashboard.putNumber("speed", speed);
        if(controlSignal == 0. || (speed < 24_000.*controlSignal && speed > -24_000.*controlSignal)) // ignore the severe transients (be sure to use the max possible speed)
          {
            flip = -flip;
         
            if(speed == 0.) speed = 1.1;

            SmartDashboard.putNumber("velocity (native units)", speed + Math.copySign(Math.ulp(speed), flip));
                  
            SmartDashboard.putNumber("filter window", filterWindow);
            SmartDashboard.putNumber("filter period", filterPeriod);
            SmartDashboard.putNumber("%VBus", controlSignal);
            SmartDashboard.updateValues();
          }
        };

      // get and display the motor parms
      TalonFXConfiguration allConfigs = new TalonFXConfiguration();
      if (flywheelMotor.getAllConfigs(allConfigs, TIMEOUT_MS) != ErrorCode.OK) System.out.println("get config error");
      System.out.println("[Talon] flywheel motor configs\n" + allConfigs);
    }

public void sweepVelocity()
{
    // Talon velocity filter parameters (samples computed every 1 ms)
    SensorVelocityMeasPeriod[] vmp = { // look-back period. Bigger gives more significant digits and more lag.
      SensorVelocityMeasPeriod.Period_1Ms,
      SensorVelocityMeasPeriod.Period_2Ms,
      SensorVelocityMeasPeriod.Period_5Ms,
      SensorVelocityMeasPeriod.Period_10Ms,
      SensorVelocityMeasPeriod.Period_20Ms,
      SensorVelocityMeasPeriod.Period_25Ms,
      SensorVelocityMeasPeriod.Period_50Ms,
      SensorVelocityMeasPeriod.Period_100Ms
      };

    int[] ws = {1,2,4,8,16,32}; // rolling average Window Size ms. Bigger is smoother and more lag.

  // for all measurement periods (1 ms to 100ms)
  // sweep velocity from 0 to +1 step 0.05 in about 100 seconds. Hold each velocity for some seconds

  for (int selectPeriod = 0; selectPeriod < vmp.length; selectPeriod++)
  // for (int selectPeriod = 2; selectPeriod <= 3; selectPeriod++)
  {
    // set the period
    filterPeriod = vmp[selectPeriod].value;
    SmartDashboard.putNumber("filter period", filterPeriod);
    System.out.println("period " + vmp[selectPeriod]);
    if (flywheelMotor.configVelocityMeasurementPeriod(vmp[selectPeriod], TIMEOUT_MS) != ErrorCode.OK) System.out.println("config meas period");

    
  double speed;
      
  for (int selectWindow = 0; selectWindow < ws.length; selectWindow++)
  // for (int selectWindow = 0; selectWindow <= 1; selectWindow++)
  {
    // set the window
    filterWindow = ws[selectWindow];
    SmartDashboard.putNumber("filter window", filterWindow);
    System.out.println("__window " + filterWindow + " ms");
    if (flywheelMotor.configVelocityMeasurementWindow(filterWindow, TIMEOUT_MS) != ErrorCode.OK) System.out.println("config meas window");
    
    // sweep the velocities
    for(double controlSignal = 0.; controlSignal < 1.01; controlSignal += 0.1)
    {
      if (isDisabled()) // check for stop signal from user
      {
        setFlywheelControlSignal.accept(0.); // stop motor at end of sweep
        printSpeed.accept(0., 0.);

        try {
          Thread.sleep(1_000L);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        return;
      }
  
      // set the velocity
      setFlywheelControlSignal.accept(controlSignal);

      // run velocity for awhile sampling and printing it often
      for (int count = 1; count <= 350; count++)
      {
        speed = getFlywheelSpeed.get();
        printSpeed.accept(controlSignal, speed);
        try {
          Thread.sleep(5L);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
    }

    while((speed = getFlywheelSpeed.get()) > 0)
    {
      System.out.println("waiting for motor to stop moving " + speed);
      setFlywheelControlSignal.accept(0.); // stop motor at end of sweep
      printSpeed.accept(0., speed);
      try {
        Thread.sleep(5L);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  }
}

}
// protected void loopFunc() {
//   m_watchdog.reset();

//   // Call the appropriate function depending upon the current robot mode
//   if (isDisabled()) {
//     // Call DisabledInit() if we are now just entering disabled mode from either a different mode
//     // or from power-on.
//     if (m_lastMode != Mode.kDisabled) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       disabledInit();
//       m_watchdog.addEpoch("disabledInit()");
//       m_lastMode = Mode.kDisabled;
//     }

//     HAL.observeUserProgramDisabled();
//     disabledPeriodic();
//     m_watchdog.addEpoch("disablePeriodic()");
//   } else if (isAutonomous()) {
//     // Call AutonomousInit() if we are now just entering autonomous mode from either a different
//     // mode or from power-on.
//     if (m_lastMode != Mode.kAutonomous) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       autonomousInit();
//       m_watchdog.addEpoch("autonomousInit()");
//       m_lastMode = Mode.kAutonomous;
//     }

//     HAL.observeUserProgramAutonomous();
//     autonomousPeriodic();
//     m_watchdog.addEpoch("autonomousPeriodic()");
//   } else if (isOperatorControl()) {
//     // Call TeleopInit() if we are now just entering teleop mode from either a different mode or
//     // from power-on.
//     if (m_lastMode != Mode.kTeleop) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       teleopInit();
//       m_watchdog.addEpoch("teleopInit()");
//       m_lastMode = Mode.kTeleop;
//     }

//     HAL.observeUserProgramTeleop();
//     teleopPeriodic();
//     m_watchdog.addEpoch("teleopPeriodic()");
//   } else {
//     // Call TestInit() if we are now just entering test mode from either a different mode or from
//     // power-on.
//     if (m_lastMode != Mode.kTest) {
//       LiveWindow.setEnabled(true);
//       Shuffleboard.enableActuatorWidgets();
//       testInit();
//       m_watchdog.addEpoch("testInit()");
//       m_lastMode = Mode.kTest;
//     }

//     HAL.observeUserProgramTest();
//     testPeriodic();
//     m_watchdog.addEpoch("testPeriodic()");
//   }
