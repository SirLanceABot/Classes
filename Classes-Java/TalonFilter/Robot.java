// DISPLAY TalonFX (Falcon 500) velocity native units versus time for selected %VBus, filterWindow size, and filterPeriod length
// If using the sweepVelocity method it's all automatic and does all the combinations for the parametric analysis

// Copy of CTRE method help
  /**
   * configVelocityMeasurementWindow
	 * Sets the number of velocity samples used in the rolling average velocity
	 * measurement.
	 *
	 * @param windowSize
	 *            Number of samples in the rolling average of velocity
	 *            measurement. Valid values are 1,2,4,8,16,32. If another
	 *            value is specified, it will truncate to nearest support value.
	 * @return Error Code generated by function. 0 indicates no error.
	 */

	/**
   * configVelocityMeasurementPeriod
	 * Configures the period of each velocity sample.
	 * Every 1ms a position value is sampled, and the delta between that sample
	 * and the position sampled kPeriod ms ago is inserted into a filter.
	 * kPeriod is configured with this function.
	 *
	 * @param period
	 *            Desired period for the velocity measurement. @see
	 *            com.ctre.phoenix.sensors.SensorVelocityMeasPeriod
	 * @return Error Code generated by function. 0 indicates no error.
	 */

package frc.robot;

import java.util.function.BiConsumer;
import java.util.function.Consumer;
import java.util.function.Supplier;

import edu.wpi.first.hal.HAL;
import edu.wpi.first.util.datalog.DataLog;
import edu.wpi.first.util.datalog.DoubleLogEntry;
import edu.wpi.first.wpilibj.DataLogManager;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.RobotBase;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.ctre.phoenix.ErrorCode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.StatusFrameEnhanced;
import com.ctre.phoenix.motorcontrol.TalonFXControlMode;
import com.ctre.phoenix.motorcontrol.can.TalonFX;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.sensors.SensorVelocityMeasPeriod;

  public class Robot extends RobotBase {
  
    public void disabled() {}
  
    public void autonomous() {}
  
    public void test() {}
  
    private volatile boolean m_exit;
  
  TalonFX flywheelMotor;
  private static final int TIMEOUT_MS = 30; //milliseconds
  final int pidIdx = 0; // Talon primary closed loop control (or none)

  BiConsumer<Double, Double> printSpeed;
  Consumer<Double> setFlywheelControlSignal;
  Supplier<Double> getFlywheelSpeed;
  
  double controlSignal = 0.; // %VBus
  int filterWindow = 1;
  double filterPeriod = 100.;
  
  private static final int sampleTime = 5; // milliseconds robot loop sample time period

  Timer time = new Timer();

  private double flip = -1.;

  private DoubleLogEntry filterPeriodEntry;
  private DoubleLogEntry filterWindowEntry;
  private DoubleLogEntry controlSignalEntry;    
  private DoubleLogEntry Q0fnsLogEntry; // could use DoubleArrayLogEntry but the elements are semi-colon delimited which is hard to use in Excel
  private DoubleLogEntry Q1fnsLogEntry;
  private DoubleLogEntry Q2fnsLogEntry;
  private DoubleLogEntry Q3fnsLogEntry;
  private DoubleLogEntry Q4fnsLogEntry;
  private DoubleLogEntry IQRLogEntry;

  Robot()
  {
    LiveWindow.disableAllTelemetry(); // don't waste time on stuff we don't need
  }

  /**
   * main loop
   */
  @Override
  public void startCompetition() {
    robotInit();

    // Done with initialization so tell the DS that the robot code is ready
    HAL.observeUserProgramStarting();

    // Loop forever, calling the appropriate functions
    while (true) {
      loopFunc();
    }

  }

  @Override
  public void endCompetition() {
    m_exit = true;
  }

  public void robotInit() {

    DataLog log = DataLogManager.getLog();
    String talonFilterName = new String("/TalonFilter/"); // make a prefix tree structure for the ultrasonic data
    Q0fnsLogEntry = new DoubleLogEntry(log, talonFilterName+"Q0 fns", "velocities");
    Q1fnsLogEntry = new DoubleLogEntry(log, talonFilterName+"Q1 fns", "velocities");
    Q2fnsLogEntry = new DoubleLogEntry(log, talonFilterName+"Q2 fns", "velocities");
    Q3fnsLogEntry = new DoubleLogEntry(log, talonFilterName+"Q3 fns", "velocities");
    Q4fnsLogEntry = new DoubleLogEntry(log, talonFilterName+"Q4 fns", "velocities");
    IQRLogEntry = new DoubleLogEntry(log, talonFilterName+"IQR", "velocities");
    filterPeriodEntry = new DoubleLogEntry(log, talonFilterName+"Period", "ms");    
    filterWindowEntry = new DoubleLogEntry(log, talonFilterName+"Window", "ms");    
    controlSignalEntry = new DoubleLogEntry(log, talonFilterName+"controlSignal", "%VBus");

    configFlywheel();

    System.out.println("Select rolling average window size 1,2,4,8,16,32 ms.\nBigger is smoother and more lag.");

    System.out.println("Select accumulator look-back period ms from list. Incorrect values become 100ms.\nBigger gives more significant digits and more lag.");
    for(SensorVelocityMeasPeriod svmp : SensorVelocityMeasPeriod.values())
    {
      System.out.println(svmp);
    };

    printSpeed.accept(controlSignal, 0.);
  }

  private void loopFunc()
  {
    while (!Thread.currentThread().isInterrupted() && !m_exit) {
      if (isDisabled()) {
        DriverStation.inDisabled(true);
        disabled();
        DriverStation.inDisabled(false);
        while (isDisabled()) {
          DriverStation.waitForData();
        }
      } else if (isAutonomous()) {
        DriverStation.inAutonomous(true);
        autonomous();
        DriverStation.inAutonomous(false);
        while (isAutonomousEnabled()) {
          DriverStation.waitForData();
        }
      } else if (isTest()) {
        LiveWindow.setEnabled(true);
        Shuffleboard.enableActuatorWidgets();
        DriverStation.inTest(true);
        test();
        DriverStation.inTest(false);
        while (isTest() && isEnabled()) {
          DriverStation.waitForData();
        }
        LiveWindow.setEnabled(false);
        Shuffleboard.disableActuatorWidgets();
      } else {
        DriverStation.inTeleop(true);
        // teleop();
        sweepVelocity();// sweep velocities through periods
        DriverStation.inTeleop(false);
        while (isTeleopEnabled()) {
          DriverStation.waitForData();
        }
      }
    }
  }
  // DriverStation.waitForData(0.1);// () (0) (seconds)
  // DriverStation.isNewControlData();

  public void teleop() {
  
    System.out.println("teleop entered");
    // try {
    //   Thread.sleep(10);
    // } catch (InterruptedException e) {
    //   // TODO Auto-generated catch block
    //   e.printStackTrace();
    // }

    // System.out.format("%5.2f %5d %5.2f %5.2f %5.2f\n", robbie.controlSignal, robbie.filterWindow, robbie.filterPeriod, vmin, vmax);

    controlSignal = SmartDashboard.getNumber("%VBus", controlSignal);

    filterWindow = (int)SmartDashboard.getNumber("filter window", filterWindow);

    flywheelMotor.configVelocityMeasurementWindow(filterWindow/*, TIMEOUT_MS*/);

    filterPeriod = SmartDashboard.getNumber("filter period", filterPeriod);

    flywheelMotor.configVelocityMeasurementPeriod(SensorVelocityMeasPeriod.valueOf(filterPeriod)/*, TIMEOUT_MS*/);

    setFlywheelControlSignal.accept(controlSignal);
    var speed = getFlywheelSpeed.get();
    printSpeed.accept(controlSignal, speed);

    System.out.println("teleop returned");

  }

  void configFlywheel()
  {
      int flywheelMotorPort=0;
      flywheelMotor = new TalonFX(flywheelMotorPort);
      System.out.println("[Talon] set factory default " + flywheelMotor.configFactoryDefault(TIMEOUT_MS));
      flywheelMotor.setInverted(false);
      if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set inverted error " + flywheelMotor.getLastError());
      flywheelMotor.setNeutralMode(NeutralMode.Coast);
      if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set neutral mode error " + flywheelMotor.getLastError());
      System.out.println("[Talon] set vel period " + flywheelMotor.configVelocityMeasurementPeriod(SensorVelocityMeasPeriod.Period_25Ms, TIMEOUT_MS));
      System.out.println("[Talon] set vel window " + flywheelMotor.configVelocityMeasurementWindow(1, TIMEOUT_MS));
      FeedbackDevice sensor = FeedbackDevice.IntegratedSensor;
      System.out.println("[Talon] set feedback sensor " + sensor.toString() + " " + flywheelMotor.configSelectedFeedbackSensor(sensor, 0, TIMEOUT_MS));
      System.out.println("[Talon] set nominal output reverse " + flywheelMotor.configNominalOutputReverse(0., TIMEOUT_MS));
      System.out.println("[Talon] set status 2 " + flywheelMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_2_Feedback0, sampleTime, TIMEOUT_MS));
      System.out.println("[Talon] set status 13 " + flywheelMotor.setStatusFramePeriod(StatusFrameEnhanced.Status_13_Base_PIDF0, sampleTime, TIMEOUT_MS)); // PID error
      flywheelMotor.setSensorPhase(false);
      if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set sensor phase error " + flywheelMotor.getLastError());
      flywheelMotor.setSelectedSensorPosition(0, pidIdx, TIMEOUT_MS);
      if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set sensor position error " + flywheelMotor.getLastError());

      // get and display the motor parms
      TalonFXConfiguration allConfigs = new TalonFXConfiguration();
      if (flywheelMotor.getAllConfigs(allConfigs, TIMEOUT_MS) != ErrorCode.OK) System.out.println("get config error" + flywheelMotor.getLastError());
      System.out.println("[Talon] flywheel motor configs\n" + allConfigs);
    
      setFlywheelControlSignal = (speed) -> 
      {
        flywheelMotor.set(TalonFXControlMode.PercentOutput, speed);
        if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("set error " + flywheelMotor.getLastError());
      };

      getFlywheelSpeed = () ->
      {
        var speed = flywheelMotor.getSelectedSensorVelocity(pidIdx);
        if(flywheelMotor.getLastError() != ErrorCode.OK) System.out.println("get sensor error " + flywheelMotor.getLastError());
        return speed;
      };

      printSpeed = (controlSignal, speed) ->
      {
        SmartDashboard.putNumber("speed", speed);
        if((speed <= 24_000.*controlSignal && speed >= -24_000.*controlSignal) // ignore the severe transients (be sure to use the max possible speed)
         || (controlSignal == 0 && speed <= 24_000. && speed >= -24_000.))
          {
            flip = -flip;
         
            if(speed == 0.) speed = 1.1;

            SmartDashboard.putNumber("velocity (native units)", speed + Math.copySign(Math.ulp(speed), flip));
                  
            SmartDashboard.putNumber("filter window", filterWindow);
            SmartDashboard.putNumber("filter period", filterPeriod);
            SmartDashboard.putNumber("%VBus", controlSignal);
            SmartDashboard.updateValues();
          }
      };

    }

public void sweepVelocity()
{
    // Talon velocity filter parameters (samples computed every 1 ms)
    SensorVelocityMeasPeriod[] vmp = { // look-back period. Bigger gives more significant digits and more lag.
      SensorVelocityMeasPeriod.Period_1Ms,
      SensorVelocityMeasPeriod.Period_2Ms,
      SensorVelocityMeasPeriod.Period_5Ms,
      SensorVelocityMeasPeriod.Period_10Ms,
      SensorVelocityMeasPeriod.Period_20Ms,
      SensorVelocityMeasPeriod.Period_25Ms,
      SensorVelocityMeasPeriod.Period_50Ms,
      SensorVelocityMeasPeriod.Period_100Ms
      };

    int[] ws = {1,2,4,8,16,32}; // rolling average Window Size ms. Bigger is smoother and more lag.

  // for all measurement periods (1 ms to 100ms)
  // sweep velocity from 0 to +1 step 0.05. Hold each velocity for some seconds

  for (int selectPeriod = 0; selectPeriod < vmp.length; selectPeriod++)
  {
    // set the period
    filterPeriod = vmp[selectPeriod].value;
    SmartDashboard.putNumber("filter period", filterPeriod);
    if (flywheelMotor.configVelocityMeasurementPeriod(vmp[selectPeriod], TIMEOUT_MS) != ErrorCode.OK) System.out.println("config meas period" + flywheelMotor.getLastError());
    
  double speed;
      
  for (int selectWindow = 0; selectWindow < ws.length; selectWindow++)
  {
    // set the window
    filterWindow = ws[selectWindow];
    SmartDashboard.putNumber("filter window", filterWindow);
    System.out.println("period " + vmp[selectPeriod]);
    System.out.println("__window " + filterWindow + " ms");
    if (flywheelMotor.configVelocityMeasurementWindow(filterWindow, TIMEOUT_MS) != ErrorCode.OK) System.out.println("config meas window" + flywheelMotor.getLastError());
    
    // sweep the velocities
    for(double controlSignal = 0.; controlSignal < 1.01; controlSignal += 0.1)
    {
      // check for stop signal from user
      // User can "disable" with Driver Station or "enter" but that only disables the motors and actuators
      // and does not break the "loop". This method keeps running just the motors stopped spinning
      // unless we check for the disable signal ourself and stop this method.
      // Thus "disable" does disable motors and actuators but is merely a suggestion to the program
      // that must check for disabled if it wants to do something on disable.
      // Note that since the method continues to run, if the user re-enables, the motors will start immediately
      // in the state the method currently is in. There was NO suspended animation or PAUSE unless programed.
      if (isDisabled())
      {
        setFlywheelControlSignal.accept(0.); // stop motor at end of sweep
        printSpeed.accept(0., 0.);

        try {
          Thread.sleep(1_000L);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
        return; // goes back to main loop that would restart the sweepVelocities from the beginning.
                // robotInit is not rerun unless the user restarts robot code.
      }
  
      // set the velocity
      setFlywheelControlSignal.accept(controlSignal);

      // run velocity for awhile sampling and printing it often

      double[] data = new double[250]; // save last 250 points for fiveNumberSummary and IQR
      for (int count = 1; count <= 350; count++)
      {
        speed = getFlywheelSpeed.get();
        if(count >= 101) data[count-101] = speed;
        printSpeed.accept(controlSignal, speed);
        try {
          Thread.sleep(5L);
        } catch (InterruptedException e) {
          e.printStackTrace();
        }
      }
      double[] fns = IQR.fiveNumberSummary(data);
      System.out.println(IQR.dump(fns));
      Q0fnsLogEntry.append(fns[0]);
      Q1fnsLogEntry.append(fns[1]);
      Q2fnsLogEntry.append(fns[2]);
      Q3fnsLogEntry.append(fns[3]);
      Q4fnsLogEntry.append(fns[4]);
      IQRLogEntry.append(fns[3]-fns[1]);
      filterPeriodEntry.append(filterPeriod);
      filterWindowEntry.append(filterWindow);
      controlSignalEntry.append(controlSignal);
    }

    while((speed = getFlywheelSpeed.get()) > 0)
    {
      // System.out.println("waiting for motor to stop moving " + speed);
      setFlywheelControlSignal.accept(0.); // stop motor at end of sweep
      printSpeed.accept(0., speed);
      try {
        Thread.sleep(5L);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
    }
  }
  }
}

}
// protected void loopFunc() {
//   m_watchdog.reset();

//   // Call the appropriate function depending upon the current robot mode
//   if (isDisabled()) {
//     // Call DisabledInit() if we are now just entering disabled mode from either a different mode
//     // or from power-on.
//     if (m_lastMode != Mode.kDisabled) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       disabledInit();
//       m_watchdog.addEpoch("disabledInit()");
//       m_lastMode = Mode.kDisabled;
//     }

//     HAL.observeUserProgramDisabled();
//     disabledPeriodic();
//     m_watchdog.addEpoch("disablePeriodic()");
//   } else if (isAutonomous()) {
//     // Call AutonomousInit() if we are now just entering autonomous mode from either a different
//     // mode or from power-on.
//     if (m_lastMode != Mode.kAutonomous) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       autonomousInit();
//       m_watchdog.addEpoch("autonomousInit()");
//       m_lastMode = Mode.kAutonomous;
//     }

//     HAL.observeUserProgramAutonomous();
//     autonomousPeriodic();
//     m_watchdog.addEpoch("autonomousPeriodic()");
//   } else if (isOperatorControl()) {
//     // Call TeleopInit() if we are now just entering teleop mode from either a different mode or
//     // from power-on.
//     if (m_lastMode != Mode.kTeleop) {
//       LiveWindow.setEnabled(false);
//       Shuffleboard.disableActuatorWidgets();
//       teleopInit();
//       m_watchdog.addEpoch("teleopInit()");
//       m_lastMode = Mode.kTeleop;
//     }

//     HAL.observeUserProgramTeleop();
//     teleopPeriodic();
//     m_watchdog.addEpoch("teleopPeriodic()");
//   } else {
//     // Call TestInit() if we are now just entering test mode from either a different mode or from
//     // power-on.
//     if (m_lastMode != Mode.kTest) {
//       LiveWindow.setEnabled(true);
//       Shuffleboard.enableActuatorWidgets();
//       testInit();
//       m_watchdog.addEpoch("testInit()");
//       m_lastMode = Mode.kTest;
//     }

//     HAL.observeUserProgramTest();
//     testPeriodic();
//     m_watchdog.addEpoch("testPeriodic()");
//   }